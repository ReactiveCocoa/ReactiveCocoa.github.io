<!DOCTYPE html>
<html lang="en">
  <head>
    <title>DesignGuidelines  Reference</title>
    <link rel="stylesheet" type="text/css" href="css/jazzy.css" />
    <link rel="stylesheet" type="text/css" href="css/highlight.css" />
    <meta charset="utf-8">
    <script src="js/jquery.min.js" defer></script>
    <script src="js/jazzy.js" defer></script>
    
  </head>
  <body>


    <a title="DesignGuidelines  Reference"></a>

    <header class="header">
      <p class="header-col header-col--primary">
        <a class="header-link" href="index.html">
          ReactiveSwift Docs
        </a>
        
      </p>
    
        <p class="header-col header-col--secondary">
          <a class="header-link" href="https://github.com/ReactiveCocoa/ReactiveSwift/">
            <img class="header-icon" src="img/gh.png"/>
            View on GitHub
          </a>
        </p>
    
    </header>

    <p class="breadcrumbs">
      <a class="breadcrumb" href="index.html">ReactiveSwift Reference</a>
      <img class="carat" src="img/carat.png" />
      DesignGuidelines  Reference
    </p>

    <div class="content-wrapper">
      <nav class="navigation">
        <ul class="nav-groups">
          <li class="nav-group-name">
            <a class="nav-group-name-link" href="Getting Started.html">Getting Started</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="basicoperators.html">BasicOperators</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="frameworkoverview.html">FrameworkOverview</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="debuggingtechniques.html">DebuggingTechniques</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="designguidelines.html">DesignGuidelines</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a class="nav-group-name-link" href="Signal.html">Signal</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Enums/Event.html">Event</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Protocols/EventProtocol.html">EventProtocol</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/Observer.html">Observer</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Protocols/ObserverProtocol.html">ObserverProtocol</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/Signal.html">Signal</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Protocols/SignalProtocol.html">SignalProtocol</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Enums/FlattenStrategy.html">FlattenStrategy</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a class="nav-group-name-link" href="SignalProducer.html">SignalProducer</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Structs/SignalProducer.html">SignalProducer</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Protocols/SignalProducerProtocol.html">SignalProducerProtocol</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="SignalProducer.html#/s:F13ReactiveSwift5timerFT8intervalO8Dispatch20DispatchTimeInterval2onPS_21DateSchedulerProtocol__GVS_14SignalProducerV10Foundation4DateO6Result7NoError_">timer(interval:on:)</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="SignalProducer.html#/s:F13ReactiveSwift5timerFT8intervalO8Dispatch20DispatchTimeInterval2onPS_21DateSchedulerProtocol_6leewayS1__GVS_14SignalProducerV10Foundation4DateO6Result7NoError_">timer(interval:on:leeway:)</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a class="nav-group-name-link" href="Property.html">Property</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/Property.html">Property</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Protocols/PropertyProtocol.html">PropertyProtocol</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/MutableProperty.html">MutableProperty</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Protocols/MutablePropertyProtocol.html">MutablePropertyProtocol</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a class="nav-group-name-link" href="Action.html">Action</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/Action.html">Action</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Enums/ActionError.html">ActionError</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Protocols/ActionProtocol.html">ActionProtocol</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a class="nav-group-name-link" href="Bindings.html">Bindings</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Protocols/BindingSourceProtocol.html">BindingSourceProtocol</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/BindingTarget.html">BindingTarget</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Protocols/BindingTargetProtocol.html">BindingTargetProtocol</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Bindings.html#/s:F13ReactiveSwiftoi2ltu0_RxS_21BindingTargetProtocol_S_21BindingSourceProtocolwx5Valuezw_5Valuew_5ErrorzO6Result7NoErrorrFTxq__GSqPS_10Disposable__">&lt;~(_:_:)</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Bindings.html#/s:F13ReactiveSwiftoi2ltu0_RxS_21BindingTargetProtocol_S_21BindingSourceProtocolwx5ValueS_16OptionalProtocolw_5ErrorzO6Result7NoErrorw_5ValuezWxS2_7Wrapped_rFTxq__GSqPS_10Disposable__">&lt;~(_:_:)</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a class="nav-group-name-link" href="Schedulers.html">Schedulers</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Protocols/DateSchedulerProtocol.html">DateSchedulerProtocol</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/ImmediateScheduler.html">ImmediateScheduler</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/QueueScheduler.html">QueueScheduler</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Protocols/SchedulerProtocol.html">SchedulerProtocol</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/TestScheduler.html">TestScheduler</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/UIScheduler.html">UIScheduler</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a class="nav-group-name-link" href="Reactive Extensions.html">Reactive Extensions</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Structs/Reactive.html">Reactive</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Protocols/ReactiveExtensionsProvider.html">ReactiveExtensionsProvider</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a class="nav-group-name-link" href="Lifetime.html">Lifetime</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/Lifetime.html">Lifetime</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/Lifetime.html#/s:CC13ReactiveSwift8Lifetime5Token">– Token</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a class="nav-group-name-link" href="Disposable.html">Disposable</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/AnyDisposable.html">AnyDisposable</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/ActionDisposable.html">ActionDisposable</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Protocols/Disposable.html">Disposable</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/CompositeDisposable.html">CompositeDisposable</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/CompositeDisposable/DisposableHandle.html">– DisposableHandle</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/ScopedDisposable.html">ScopedDisposable</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/SerialDisposable.html">SerialDisposable</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/SimpleDisposable.html">SimpleDisposable</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Disposable.html#/s:F13ReactiveSwiftoi2peFTCS_19CompositeDisposableGSqPS_10Disposable___CS0_16DisposableHandle">+=(_:_:)</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Disposable.html#/s:F13ReactiveSwiftoi2peFTCS_19CompositeDisposableFT_T__CS0_16DisposableHandle">+=(_:_:)</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Disposable.html#/s:F13ReactiveSwiftoi2peFTGCS_16ScopedDisposableCS_19CompositeDisposable_GSqPS_10Disposable___CS1_16DisposableHandle">+=(_:_:)</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Disposable.html#/s:F13ReactiveSwiftoi2peFTGCS_16ScopedDisposableCS_19CompositeDisposable_FT_T__CS1_16DisposableHandle">+=(_:_:)</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a class="nav-group-name-link" href="Utilities.html">Utilities</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/Atomic.html">Atomic</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Protocols/AtomicProtocol.html">AtomicProtocol</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Structs/Bag.html">Bag</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Structs/BagIterator.html">BagIterator</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Utilities.html#/s:C13ReactiveSwift12RemovalToken">RemovalToken</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Utilities.html#/s:13ReactiveSwift11EventLogger">EventLogger</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Utilities.html#/s:O13ReactiveSwift12LoggingEvent">LoggingEvent</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Extensions/Optional.html">Optional</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Protocols/OptionalProtocol.html">OptionalProtocol</a>
              </li>
            </ul>
          </li>
        </ul>
      </nav>
      <article class="main-content">

        <section class="section">
          <div class="section-content">
            
            <a href='#design-guidelines' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h1 id='design-guidelines'>Design Guidelines</h1>

<p>This document contains guidelines for projects that want to make use of
ReactiveSwift. The content here is heavily inspired by the <a href="http://blogs.msdn.com/b/rxteam/archive/2010/10/28/rx-design-guidelines.aspx">Rx Design
Guidelines</a>.</p>

<p>This document assumes basic familiarity
with the features of ReactiveSwift. The <a href="FrameworkOverview.md">Framework Overview</a> is a better
resource for getting up to speed on the main types and concepts provided by ReactiveSwift.</p>

<p><strong><a href="#the-event-contract">The <code>Event</code> contract</a></strong></p>

<ol>
<li><a href="#values-provide-values-or-indicate-the-occurrence-of-events"><code>value</code>s provide values or indicate the occurrence of events</a></li>
<li><a href="#failures-behave-like-exceptions-and-propagate-immediately"><code>failure</code>s behave like exceptions and propagate immediately</a></li>
<li><a href="#completion-indicates-success"><code>completion</code> indicates success</a></li>
<li><a href="#interruptions-cancel-outstanding-work-and-usually-propagate-immediately"><code>interruption</code>s cancel outstanding work and usually propagate immediately</a></li>
<li><a href="#events-are-serial">Events are serial</a></li>
<li><a href="#events-cannot-be-sent-recursively">Events cannot be sent recursively</a></li>
<li><a href="#events-are-sent-synchronously-by-default">Events are sent synchronously by default</a></li>
</ol>

<p><strong><a href="#the-signal-contract">The <code>Signal</code> contract</a></strong></p>

<ol>
<li><a href="#signals-start-work-when-instantiated">Signals start work when instantiated</a></li>
<li><a href="#observing-a-signal-does-not-have-side-effects">Observing a signal does not have side effects</a></li>
<li><a href="#all-observers-of-a-signal-see-the-same-events-in-the-same-order">All observers of a signal see the same events in the same order</a></li>
<li><a href="#a-signal-is-alive-as-long-as-it-is-publicly-reachable-or-is-being-observed">A signal is alive as long as it is publicly reachable or is being observed</a></li>
<li><a href="#terminating-events-dispose-of-signal-resources">Terminating events dispose of signal resources</a></li>
</ol>

<p><strong><a href="#the-signalproducer-contract">The <code>SignalProducer</code> contract</a></strong></p>

<ol>
<li><a href="#signal-producers-start-work-on-demand-by-creating-signals">Signal producers start work on demand by creating signals</a></li>
<li><a href="#each-produced-signal-may-send-different-events-at-different-times">Each produced signal may send different events at different times</a></li>
<li><a href="#signal-operators-can-be-lifted-to-apply-to-signal-producers">Signal operators can be lifted to apply to signal producers</a></li>
<li><a href="#disposing-of-a-produced-signal-will-interrupt-it">Disposing of a produced signal will interrupt it</a></li>
</ol>

<p><strong><a href="#best-practices">Best practices</a></strong></p>

<ol>
<li><a href="#process-only-as-many-values-as-needed">Process only as many values as needed</a></li>
<li><a href="#observe-events-on-a-known-scheduler">Observe events on a known scheduler</a></li>
<li><a href="#switch-schedulers-in-as-few-places-as-possible">Switch schedulers in as few places as possible</a></li>
<li><a href="#capture-side-effects-within-signal-producers">Capture side effects within signal producers</a></li>
<li><a href="#share-the-side-effects-of-a-signal-producer-by-sharing-one-produced-signal">Share the side effects of a signal producer by sharing one produced signal</a></li>
<li><a href="#prefer-managing-lifetime-with-operators-over-explicit-disposal">Prefer managing lifetime with operators over explicit disposal</a></li>
</ol>

<p><strong><a href="#implementing-new-operators">Implementing new operators</a></strong></p>

<ol>
<li><a href="#prefer-writing-operators-that-apply-to-both-signals-and-producers">Prefer writing operators that apply to both signals and producers</a></li>
<li><a href="#compose-existing-operators-when-possible">Compose existing operators when possible</a></li>
<li><a href="#forward-failure-and-interruption-events-as-soon-as-possible">Forward failure and interruption events as soon as possible</a></li>
<li><a href="#switch-over-event-values">Switch over <code>Event</code> values</a></li>
<li><a href="#avoid-introducing-concurrency">Avoid introducing concurrency</a></li>
<li><a href="#avoid-blocking-in-operators">Avoid blocking in operators</a></li>
</ol>
<a href='#the-code-event-code-contract' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h2 id='the-code-event-code-contract'>The <code>Event</code> contract</h2>

<p><a href="FrameworkOverview.md#events">Events</a> are fundamental to ReactiveSwift. <a href="FrameworkOverview.md#signals">Signals</a> and <a href="FrameworkOverview.md#signal-producers">signal producers</a> both send
events, and may be collectively called “event streams.”</p>

<p>Event streams must conform to the following grammar:</p>
<pre class="highlight plaintext"><code>value* (interrupted | failed | completed)?
</code></pre>

<p>This states that an event stream consists of:</p>

<ol>
<li>Any number of <code>value</code> events</li>
<li>Optionally followed by one terminating event, which is any of <code>interrupted</code>, <code>failed</code>, or <code>completed</code></li>
</ol>

<p>After a terminating event, no other events will be received.</p>
<a href='#code-value-code-s-provide-values-or-indicate-the-occurrence-of-events' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h4 id='code-value-code-s-provide-values-or-indicate-the-occurrence-of-events'><code>value</code>s provide values or indicate the occurrence of events</h4>

<p><code>value</code> events contain a payload known as the “value”. Only <code>value</code> events are
said to have a value. Since an event stream can contain any number of <code>value</code>s,
there are few restrictions on what those values can mean or be used for, except
that they must be of the same type.</p>

<p>As an example, the value might represent an element from a collection, or
a progress update about some long-running operation. The value of a <code>value</code> event
might even represent nothing at all—for example, it’s common to use a value type
of <code>()</code> to indicate that something happened, without being more specific about
what that something was.</p>

<p>Most of the event stream <a href="BasicOperators.md">operators</a> act upon <code>value</code> events, as they represent the
“meaningful data” of a signal or producer.</p>
<a href='#code-failure-code-s-behave-like-exceptions-and-propagate-immediately' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h4 id='code-failure-code-s-behave-like-exceptions-and-propagate-immediately'><code>failure</code>s behave like exceptions and propagate immediately</h4>

<p><code>failed</code> events indicate that something went wrong, and contain a concrete error
that indicates what happened. Failures are fatal, and propagate as quickly as
possible to the consumer for handling.</p>

<p>Failures also behave like exceptions, in that they “skip” operators, terminating
them along the way. In other words, most <a href="BasicOperators.md">operators</a> immediately stop doing
work when a failure is received, and then propagate the failure onward. This even applies to time-shifted operators, like <a href="../ReactiveCocoa/Swift/Signal.swift"><code>delay</code></a>—which, despite its name, will forward any failures immediately.</p>

<p>Consequently, failures should only be used to represent “abnormal” termination. If it is important to let operators (or consumers) finish their work, a <code>value</code>
event describing the result might be more appropriate.</p>

<p>If an event stream can <em>never</em> fail, it should be parameterized with the
special <a href="../ReactiveCocoa/Swift/Errors.swift"><code>NoError</code></a> type, which statically guarantees that a <code>failed</code>
event cannot be sent upon the stream.</p>
<a href='#code-completion-code-indicates-success' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h4 id='code-completion-code-indicates-success'><code>completion</code> indicates success</h4>

<p>An event stream sends <code>completed</code> when the operation has completed successfully,
or to indicate that the stream has terminated normally.</p>

<p>Many operators manipulate the <code>completed</code> event to shorten or extend the
lifetime of an event stream.</p>

<p>For example, <a href="../ReactiveCocoa/Swift/Signal.swift"><code>take</code></a> will complete after the specified number of values have
been received, thereby terminating the stream early. On the other hand, most
operators that accept multiple signals or producers will wait until <em>all</em> of
them have completed before forwarding a <code>completed</code> event, since a successful
outcome will usually depend on all the inputs.</p>
<a href='#code-interruption-code-s-cancel-outstanding-work-and-usually-propagate-immediately' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h4 id='code-interruption-code-s-cancel-outstanding-work-and-usually-propagate-immediately'><code>interruption</code>s cancel outstanding work and usually propagate immediately</h4>

<p>An <code>interrupted</code> event is sent when an event stream should cancel processing.
Interruption is somewhere between <a href="#completion-indicates-success">success</a>
and <a href="#failures-behave-like-exceptions-and-propagate-immediately">failure</a>—the
operation was not successful, because it did not get to finish, but it didn’t
necessarily “fail” either.</p>

<p>Most <a href="BasicOperators.md">operators</a> will propagate interruption immediately, but there are some
exceptions. For example, the <a href="BasicOperators.md#flattening-producers">flattening operators</a> will ignore
<code>interrupted</code> events that occur on the <em>inner</em> producers, since the cancellation
of an inner operation should not necessarily cancel the larger unit of work.</p>

<p>ReactiveSwift will automatically send an <code>interrupted</code> event upon <a href="FrameworkOverview.md#disposables">disposal</a>, but it can
also be sent manually if necessary. Additionally, <a href="#implementing-new-operators">custom
operators</a> must make sure to forward interruption
events to the observer.</p>
<a href='#events-are-serial' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h4 id='events-are-serial'>Events are serial</h4>

<p>ReactiveSwift guarantees that all events upon a stream will arrive serially. In other
words, it’s impossible for the observer of a signal or producer to receive
multiple <code>Event</code>s concurrently, even if the events are sent on multiple threads
simultaneously.</p>

<p>This simplifies <a href="BasicOperators.md">operator</a> implementations and <a href="FrameworkOverview.md#observers">observers</a>.</p>
<a href='#events-cannot-be-sent-recursively' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h4 id='events-cannot-be-sent-recursively'>Events cannot be sent recursively</h4>

<p>Just like ReactiveSwift guarantees that <a href="#events-are-serial">events will not be received
concurrently</a>, it also guarantees that they won’t be
received recursively. As a consequence, <a href="BasicOperators.md">operators</a> and <a href="FrameworkOverview.md#observers">observers</a> <em>do not</em> need to
be reentrant.</p>

<p>If an event is sent upon a signal from a thread that is <em>already processing</em>
a previous event from that signal, deadlock will result. This is because
recursive signals are usually programmer error, and the determinacy of
a deadlock is preferable to nondeterministic race conditions.</p>

<p>When a recursive signal is explicitly desired, the recursive event should be
time-shifted, with an operator like <a href="../ReactiveCocoa/Swift/Signal.swift"><code>delay</code></a>, to ensure that it isn’t sent from
an already-running event handler.</p>
<a href='#events-are-sent-synchronously-by-default' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h4 id='events-are-sent-synchronously-by-default'>Events are sent synchronously by default</h4>

<p>ReactiveSwift does not implicitly introduce concurrency or asynchrony. <a href="BasicOperators.md">Operators</a> that
accept a <a href="FrameworkOverview.md#schedulers">scheduler</a> may, but they must be explicitly invoked by the consumer of
the framework.</p>

<p>A “vanilla” signal or producer will send all of its events synchronously by
default, meaning that the <a href="FrameworkOverview.md#observers">observer</a> will be synchronously invoked for each event
as it is sent, and that the underlying work will not resume until the event
handler finishes.</p>

<p>This is similar to how <code>NSNotificationCenter</code> or <code>UIControl</code> events are
distributed.</p>
<a href='#the-code-signal-code-contract' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h2 id='the-code-signal-code-contract'>The <code>Signal</code> contract</h2>

<p>A <a href="FrameworkOverview.md#signals">signal</a> is a stream of values that obeys <a href="#the-event-contract">the <code>Event</code> contract</a>.</p>

<p><code>Signal</code> is a reference type, because each signal has identity — in other words, each
signal has its own lifetime, and may eventually terminate. Once terminated,
a signal cannot be restarted.</p>
<a href='#signals-start-work-when-instantiated' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h4 id='signals-start-work-when-instantiated'>Signals start work when instantiated</h4>

<p><a href="../ReactiveCocoa/Swift/Signal.swift"><code>Signal.init</code></a> immediately executes the generator closure that is passed to it.
This means that side effects may occur even before the initializer returns.</p>

<p>It is also possible to send <a href="FrameworkOverview.md#events">events</a> before the initializer returns. However,
since it is impossible for any <a href="FrameworkOverview.md#observers">observers</a> to be attached at this point, any
events sent this way cannot be received.</p>
<a href='#observing-a-signal-does-not-have-side-effects' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h4 id='observing-a-signal-does-not-have-side-effects'>Observing a signal does not have side effects</h4>

<p>The work associated with a <code>Signal</code> does not start or stop when <a href="FrameworkOverview.md#observers">observers</a> are
added or removed, so the <a href="../ReactiveCocoa/Swift/Signal.swift"><code>observe</code></a> method (or the cancellation thereof) never
has side effects.</p>

<p>A signal’s side effects can only be stopped through <a href="#signals-are-retained-until-a-terminating-event-occurs">a terminating event</a>, or by a silent disposal at the point that <a href="#a-signal-is-alive-as-long-as-it-is-publicly-reachable-or-is-being-observed">the signal is neither publicly reachable nor being observed</a>.</p>
<a href='#all-observers-of-a-signal-see-the-same-events-in-the-same-order' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h4 id='all-observers-of-a-signal-see-the-same-events-in-the-same-order'>All observers of a signal see the same events in the same order</h4>

<p>Because <a href="#observing-a-signal-does-not-have-side-effects">observation does not have side
effects</a>, a <code>Signal</code> never
customizes events for different <a href="FrameworkOverview.md#observers">observers</a>. When an event is sent upon a signal,
it will be <a href="#events-are-sent-synchronously-by-default">synchronously</a>
distributed to all observers that are attached at that time, much like
how <code>NSNotificationCenter</code> sends notifications.</p>

<p>In other words, there are not different event “timelines” per observer. All
observers effectively see the same stream of events.</p>

<p>There is one exception to this rule: adding an observer to a signal <em>after</em> it
has already terminated will result in exactly one
<a href="#interruption-cancels-outstanding-work-and-usually-propagates-immediately"><code>interrupted</code></a>
event sent to that specific observer.</p>
<a href='#a-signal-is-alive-as-long-as-it-is-publicly-reachable-or-is-being-observed' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h4 id='a-signal-is-alive-as-long-as-it-is-publicly-reachable-or-is-being-observed'>A signal is alive as long as it is publicly reachable or is being observed</h4>

<p>A <code>Signal</code> must be publicly retained for attaching new observers, but not
necessarily for keeping the stream of events alive. Moreover, a <code>Signal</code> retains
itself as long as there is still an active observer.</p>

<p>In other words, if a <code>Signal</code> is neither publicly retained nor being observed,
it would dispose of the signal resources silently.</p>

<p>Note that the input observer of a signal does not retain the signal itself.</p>

<p>Long-running side effects are recommended to be modeled as an observer to the
signal.</p>
<a href='#terminating-events-dispose-of-signal-resources' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h4 id='terminating-events-dispose-of-signal-resources'>Terminating events dispose of signal resources</h4>

<p>When a terminating <a href="FrameworkOverview.md#events">event</a> is sent along a <code>Signal</code>, all <a href="FrameworkOverview.md#observers">observers</a> will be
released, and any resources being used to generate events should be disposed of.</p>

<p>The easiest way to ensure proper resource cleanup is to return a <a href="FrameworkOverview.md#disposables">disposable</a>
from the generator closure, which will be disposed of when termination occurs.
The disposable should be responsible for releasing memory, closing file handles,
canceling network requests, or anything else that may have been associated with
the work being performed.</p>
<a href='#the-code-signalproducer-code-contract' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h2 id='the-code-signalproducer-code-contract'>The <code>SignalProducer</code> contract</h2>

<p>A <a href="FrameworkOverview.md#signal-producers">signal producer</a> is like a “recipe” for creating
<a href="FrameworkOverview.md#signals">signals</a>. Signal producers do not do anything by themselves—<a href="#signal-producers-start-work-on-demand-by-creating-signals">work begins only
when a signal is produced</a>.</p>

<p>Since a signal producer is just a declaration of <em>how</em> to create signals, it is
a value type, and has no memory management to speak of.</p>
<a href='#signal-producers-start-work-on-demand-by-creating-signals' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h4 id='signal-producers-start-work-on-demand-by-creating-signals'>Signal producers start work on demand by creating signals</h4>

<p>The <a href="../ReactiveCocoa/Swift/SignalProducer.swift"><code>start</code></a> and <a href="../ReactiveCocoa/Swift/SignalProducer.swift"><code>startWithSignal</code></a> methods each
produce a <code>Signal</code> (implicitly and explicitly, respectively). After
instantiating the signal, the closure that was passed to
<a href="../ReactiveCocoa/Swift/SignalProducer.swift"><code>SignalProducer.init</code></a> will be executed, to start the flow
of <a href="FrameworkOverview.md#events">events</a> after any observers have been attached.</p>

<p>Although the producer itself is not <em>really</em> responsible for the execution of
work, it’s common to speak of “starting” and “canceling” a producer. These terms
refer to producing a <code>Signal</code> that will start work, and <a href="#disposing-of-a-produced-signal-will-interrupt-it">disposing of that
signal</a> to stop work.</p>

<p>A producer can be started any number of times (including zero), and the work
associated with it will execute exactly that many times as well.</p>
<a href='#each-produced-signal-may-send-different-events-at-different-times' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h4 id='each-produced-signal-may-send-different-events-at-different-times'>Each produced signal may send different events at different times</h4>

<p>Because signal producers <a href="#signal-producers-start-work-on-demand-by-creating-signals">start work on
demand</a>, there may
be different <a href="FrameworkOverview.md#observers">observers</a> associated with each execution, and those observers
may see completely different <a href="FrameworkOverview.md#events">event</a> timelines.</p>

<p>In other words, events are generated from scratch for each time the producer is
started, and can be completely different (or in a completely different order)
from other times the producer is started.</p>

<p>Nonetheless, each execution of a signal producer will follow <a href="#the-event-contract">the <code>Event</code>
contract</a>.</p>
<a href='#signal-operators-can-be-lifted-to-apply-to-signal-producers' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h4 id='signal-operators-can-be-lifted-to-apply-to-signal-producers'>Signal operators can be lifted to apply to signal producers</h4>

<p>Due to the relationship between signals and signal producers, it is possible to
automatically promote any <a href="BasicOperators.md">operators</a> over one or more <code>Signal</code>s to apply to
the same number of <code>SignalProducer</code>s instead, using the <a href="../ReactiveCocoa/Swift/SignalProducer.swift"><code>lift</code></a> method.</p>

<p><code>lift</code> will apply the behavior of the specified operator to each <code>Signal</code> that
is <a href="#signal-producers-start-work-on-demand-by-creating-signals">created when the signal producer is started</a>.</p>
<a href='#disposing-of-a-produced-signal-will-interrupt-it' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h4 id='disposing-of-a-produced-signal-will-interrupt-it'>Disposing of a produced signal will interrupt it</h4>

<p>When a producer is started using the <a href="../ReactiveCocoa/Swift/SignalProducer.swift"><code>start</code></a> or
<a href="../ReactiveCocoa/Swift/SignalProducer.swift"><code>startWithSignal</code></a> methods, a <a href="FrameworkOverview.md#disposables"><code>Disposable</code></a> is
automatically created and passed back.</p>

<p>Disposing of this object will
<a href="#interruption-cancels-outstanding-work-and-usually-propagates-immediately">interrupt</a>
the produced <code>Signal</code>, thereby canceling outstanding work and sending an
<code>interrupted</code> <a href="FrameworkOverview.md#events">event</a> to all <a href="FrameworkOverview.md#observers">observers</a>, and will also dispose of
everything added to the <a href="../ReactiveCocoa/Swift/Disposable.swift"><code>CompositeDisposable</code></a> in
<a href="../ReactiveCocoa/Swift/SignalProducer.swift">SignalProducer.init</a>.</p>

<p>Note that disposing of one produced <code>Signal</code> will not affect other signals created
by the same <code>SignalProducer</code>.</p>
<a href='#best-practices' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h2 id='best-practices'>Best practices</h2>

<p>The following recommendations are intended to help keep ReactiveSwift-based code
predictable, understandable, and performant.</p>

<p>They are, however, only guidelines. Use best judgement when determining whether
to apply the recommendations here to a given piece of code.</p>
<a href='#process-only-as-many-values-as-needed' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h4 id='process-only-as-many-values-as-needed'>Process only as many values as needed</h4>

<p>Keeping an event stream alive longer than necessary can waste CPU and memory, as
unnecessary work is performed for results that will never be used.</p>

<p>If only a certain number of values or certain number of time is required from
a <a href="FrameworkOverview.md#signals">signal</a> or <a href="FrameworkOverview.md#signal-producers">producer</a>, operators like
<a href="../ReactiveCocoa/Swift/Signal.swift"><code>take</code></a> or <a href="../ReactiveCocoa/Swift/Signal.swift"><code>takeUntil</code></a> can be used to
automatically complete the stream once a certain condition is fulfilled.</p>

<p>The benefit is exponential, too, as this will terminate dependent operators
sooner, potentially saving a significant amount of work.</p>
<a href='#observe-events-on-a-known-scheduler' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h4 id='observe-events-on-a-known-scheduler'>Observe events on a known scheduler</h4>

<p>When receiving a <a href="FrameworkOverview.md#signals">signal</a> or <a href="FrameworkOverview.md#signal-producers">producer</a> from unknown
code, it can be difficult to know which thread <a href="FrameworkOverview.md#events">events</a> will arrive upon. Although
events are <a href="#events-are-serial">guaranteed to be serial</a>, sometimes stronger
guarantees are needed, like when performing UI updates (which must occur on the
main thread).</p>

<p>Whenever such a guarantee is important, the <a href="../ReactiveCocoa/Swift/Signal.swift"><code>observeOn</code></a>
<a href="BasicOperators.md">operator</a> should be used to force events to be received upon
a specific <a href="FrameworkOverview.md#schedulers">scheduler</a>.</p>
<a href='#switch-schedulers-in-as-few-places-as-possible' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h4 id='switch-schedulers-in-as-few-places-as-possible'>Switch schedulers in as few places as possible</h4>

<p>Notwithstanding the <a href="#observe-events-on-a-known-scheduler">above</a>, <a href="FrameworkOverview.md#events">events</a>
should only be delivered to a specific <a href="FrameworkOverview.md#schedulers">scheduler</a> when absolutely
necessary. Switching schedulers can introduce unnecessary delays and cause an
increase in CPU load.</p>

<p>Generally, <a href="../ReactiveCocoa/Swift/Signal.swift"><code>observeOn</code></a> should only be used right before observing
the <a href="FrameworkOverview.md#signals">signal</a>, starting the <a href="FrameworkOverview.md#signal-producers">producer</a>, or binding to
a <a href="FrameworkOverview.md#properties">property</a>. This ensures that events arrive on the expected
scheduler, without introducing multiple thread hops before their arrival.</p>
<a href='#capture-side-effects-within-signal-producers' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h4 id='capture-side-effects-within-signal-producers'>Capture side effects within signal producers</h4>

<p>Because <a href="#signal-producers-start-work-on-demand-by-creating-signals">signal producers start work on
demand</a>, any
functions or methods that return a <a href="FrameworkOverview.md#signal-producers">signal producer</a> should
make sure that side effects are captured <em>within</em> the producer itself, instead
of being part of the function or method call.</p>

<p>For example, a function like this:</p>
<pre class="highlight swift"><code><span class="kd">func</span> <span class="nf">search</span><span class="p">(</span><span class="nv">text</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">SignalProducer</span><span class="o">&lt;</span><span class="kt">Result</span><span class="p">,</span> <span class="kt">NetworkError</span><span class="o">&gt;</span>
</code></pre>

<p>… should <em>not</em> immediately start a search.</p>

<p>Instead, the returned producer should execute the search once for every time
that it is started. This also means that if the producer is never started,
a search will never have to be performed either.</p>
<a href='#share-the-side-effects-of-a-signal-producer-by-sharing-one-produced-signal' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h4 id='share-the-side-effects-of-a-signal-producer-by-sharing-one-produced-signal'>Share the side effects of a signal producer by sharing one produced signal</h4>

<p>If multiple <a href="FrameworkOverview.md#observers">observers</a> are interested in the results of a <a href="FrameworkOverview.md#signal-producers">signal
producer</a>, calling <a href="../ReactiveCocoa/Swift/SignalProducer.swift"><code>start</code></a> once for each observer
means that the work associated with the producer will <a href="#signal-producers-start-work-on-demand-by-creating-signals">execute that many
times</a> and <a href="#each-produced-signal-may-send-different-events-at-different-times">may not
generate the same results</a>.</p>

<p>If:</p>

<ol>
<li>the observers need to receive the exact same results</li>
<li>the observers know about each other, or</li>
<li>the code starting the producer knows about each observer</li>
</ol>

<p>… it may be more appropriate to start the producer <em>just once</em>, and share the
results of that one <a href="FrameworkOverview.md#signals">signal</a> to all observers, by attaching them within
the closure passed to the <a href="../ReactiveCocoa/Swift/SignalProducer.swift"><code>startWithSignal</code></a> method.</p>
<a href='#prefer-managing-lifetime-with-operators-over-explicit-disposal' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h4 id='prefer-managing-lifetime-with-operators-over-explicit-disposal'>Prefer managing lifetime with operators over explicit disposal</h4>

<p>Although the <a href="FrameworkOverview.md#disposables">disposable</a> returned from <a href="../ReactiveCocoa/Swift/SignalProducer.swift"><code>start</code></a> makes
canceling a <a href="FrameworkOverview.md#signal-producers">signal producer</a> really easy, explicit use of
disposables can quickly lead to a rat&rsquo;s nest of resource management and cleanup
code.</p>

<p>There are almost always higher-level <a href="BasicOperators.md">operators</a> that can be used instead of manual
disposal:</p>

<ul>
<li><a href="../ReactiveCocoa/Swift/Signal.swift"><code>take</code></a> can be used to automatically terminate a stream once a certain
number of values have been received.</li>
<li><a href="../ReactiveCocoa/Swift/Signal.swift"><code>takeUntil</code></a> can be used to automatically terminate
a <a href="FrameworkOverview.md#signals">signal</a> or producer when an event occurs (for example, when
a “Cancel” button is pressed in the UI).</li>
<li><a href="FrameworkOverview.md#properties">Properties</a> and the <code>&lt;~</code> operator can be used to “bind” the result of
a signal or producer, until termination or until the property is deallocated.
This can replace a manual observation that sets a value somewhere.</li>
</ul>
<a href='#implementing-new-operators' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h2 id='implementing-new-operators'>Implementing new operators</h2>

<p>ReactiveSwift provides a long list of built-in <a href="BasicOperators.md">operators</a> that should cover most use
cases; however, ReactiveSwift is not a closed system. It&rsquo;s entirely valid to implement
additional operators for specialized uses, or for consideration in ReactiveSwift
itself.</p>

<p>Implementing a new operator requires a careful attention to detail and a focus
on simplicity, to avoid introducing bugs into the calling code.</p>

<p>These guidelines cover some of the common pitfalls and help preserve the
expected API contracts. It may also help to look at the implementations of
existing <a href="FrameworkOverview.md#signals"><code>Signal</code></a> and <a href="FrameworkOverview.md#signal-producers"><code>SignalProducer</code></a> operators for reference points.</p>
<a href='#prefer-writing-operators-that-apply-to-both-signals-and-producers' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h4 id='prefer-writing-operators-that-apply-to-both-signals-and-producers'>Prefer writing operators that apply to both signals and producers</h4>

<p>Since any <a href="#signal-operators-can-be-lifted-to-apply-to-signal-producers">signal operator can apply to signal
producers</a>,
writing custom operators in terms of <a href="FrameworkOverview.md#signals"><code>Signal</code></a> means that
<a href="FrameworkOverview.md#signal-producers"><code>SignalProducer</code></a> will get it “for free.”</p>

<p>Even if the caller only needs to apply the new operator to signal producers at
first, this generality can save time and effort in the future.</p>

<p>Of course, some capabilities <em>require</em> producers (for example, any retrying or
repeating), so it may not always be possible to write a signal-based version
instead.</p>
<a href='#compose-existing-operators-when-possible' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h4 id='compose-existing-operators-when-possible'>Compose existing operators when possible</h4>

<p>Considerable thought has been put into the operators provided by ReactiveSwift, and they
have been validated through automated tests and through their real world use in
other projects. An operator that has been written from scratch may not be as
robust, or might not handle a special case that the built-in operators are aware
of.</p>

<p>To minimize duplication and possible bugs, use the provided operators as much as
possible in a custom operator implementation. Generally, there should be very
little code written from scratch.</p>
<a href='#forward-failure-and-interruption-events-as-soon-as-possible' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h4 id='forward-failure-and-interruption-events-as-soon-as-possible'>Forward failure and interruption events as soon as possible</h4>

<p>Unless an operator is specifically built to handle
<a href="#failures-behave-like-exceptions-and-propagate-immediately">failures</a> and
<a href="#interruption-cancels-outstanding-work-and-usually-propagates-immedaitely">interruptions</a>
in a custom way, it should propagate those events to the observer as soon as
possible, to ensure that their semantics are honored.</p>
<a href='#switch-over-code-event-code-values' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h4 id='switch-over-code-event-code-values'>Switch over <code>Event</code> values</h4>

<p>Create your own <a href="FrameworkOverview.md#observers">observer</a> to process raw <a href="FrameworkOverview.md#events"><code>Event</code></a> values, and use
a <code>switch</code> statement to determine the event type.</p>

<p>For example:</p>
<pre class="highlight swift"><code><span class="n">producer</span><span class="o">.</span><span class="n">start</span> <span class="p">{</span> <span class="n">event</span> <span class="k">in</span>
    <span class="k">switch</span> <span class="n">event</span> <span class="p">{</span>
    <span class="k">case</span> <span class="kd">let</span> <span class="o">.</span><span class="kt">Next</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"Next event: </span><span class="se">\(</span><span class="n">value</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>

    <span class="k">case</span> <span class="kd">let</span> <span class="o">.</span><span class="kt">Failed</span><span class="p">(</span><span class="n">error</span><span class="p">):</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"Failed event: </span><span class="se">\(</span><span class="n">error</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>

    <span class="k">case</span> <span class="o">.</span><span class="kt">Completed</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"Completed event"</span><span class="p">)</span>

    <span class="k">case</span> <span class="o">.</span><span class="kt">Interrupted</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"Interrupted event"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>

<p>Since the compiler will generate a warning if the <code>switch</code> is missing any case,
this prevents mistakes in a custom operator’s event handling.</p>
<a href='#avoid-introducing-concurrency' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h4 id='avoid-introducing-concurrency'>Avoid introducing concurrency</h4>

<p>Concurrency is an extremely common source of bugs in programming. To minimize
the potential for deadlocks and race conditions, operators should not
concurrently perform their work.</p>

<p>Callers always have the ability to <a href="#observe-events-on-a-known-scheduler">observe events on a specific
scheduler</a>, and ReactiveSwift offers built-in ways
to parallelize work, so custom operators don’t need to be concerned with it.</p>
<a href='#avoid-blocking-in-operators' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h4 id='avoid-blocking-in-operators'>Avoid blocking in operators</h4>

<p>Signal or producer operators should return a new signal or producer
(respectively) as quickly as possible. Any work that the operator needs to
perform should be part of the event handling logic, <em>not</em> part of the operator
invocation itself.</p>

<p>This guideline can be safely ignored when the purpose of an operator is to
synchronously retrieve one or more values from a stream, like <code>single()</code> or
<code>wait()</code>.</p>

          </div>
        </section>


      </article>
    </div>
    <section class="footer">
      <p>&copy; 2016 <a class="link" href="https://reactivecocoa.io/" target="_blank" rel="external">ReactiveCocoa</a>. All rights reserved. (Last updated: 2016-12-26)</p>
      <p>Generated by <a class="link" href="https://github.com/realm/jazzy" target="_blank" rel="external">jazzy ♪♫ v0.7.3</a>, a <a class="link" href="http://realm.io" target="_blank" rel="external">Realm</a> project.</p>
    </section>
  </body>
</div>
</html>
