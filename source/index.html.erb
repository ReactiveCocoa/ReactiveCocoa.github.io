---
title: ReactiveCocoa Presentation
---

<section class="title">
	<h1>
		ReactiveCocoa
	</h1>
	<p>An introduction to functional reactive programming <br>by <a href="http://ashfurrow.com/">Ash Furrow</a> — March 2014</p>
</section>

<section class="foreword light">
	<p>
		This is an interpretation of my <a href="http://mdevcon.com/posts/2014/01/09/ash-furrow/">talk</a> from <a href="http://mdevcon.com">mdevcon</a> 2014. It is heavily inspired by <a href="http://frankchimero.com/what-screens-want/">What Screens Want</a> by Frank Chimero and the case studies at <a href="http://teehanlax.com">Teehan+Lax</a>. 
	</p>
</section>

<section class="brown quote">
	<blockquote>
		“In the beginner’s mind there are many possibilities, <br />in the expert's mind there are few.”
	</blockquote>
	<p>— Shunryu Suzuki</p>	
</section>

<section class="grey history">
	<p>
		Long ago, when computer programming first came to be, machines had to be programmed quite manually. If the technician entered the correct sequence of machine codes in the correct order, then the resulting program behaviour would satisfy the business requirements. 
	</p>
	<p>
		Then we invented a high-level programming language: C. And once more, if the programmer wrote the correct sequence of instructions in the correct order, then the resulting program behaviour would satisfy the business requirements. 
	</p>
	<h1 class="emph">
		The 1980's: A Revolution in Software
	</h1>
	<p>
		The 1980's saw the invention of a new way to write computer programs: object-oriented programming. The programmer would write code that manipulated the data belonging to re-usable "objects", and if the programmer wrote the correct instructions in the correct order, then the resulting program behaviour would satisfy the business requirements. 
	</p>
	<p>
		After that, things got pretty boring.
	</p>
</section>

<section class="light danger">
	<p>
		Most modern programming today is <em>basically imperative</em>, meaning it models the traditional fetch-execute cycle of a CPU. Perform and instruction, fetch the next one. Perform that one, and so on. For decades, programmers have had to mould their brains to fit the paradigm of the CPU. 
	</p>
	<h1 class="emph">
		Imperative Programming is Dangerous
	</h1>
	<p>
		When we rely on hoping that the behaviour that emerges from a program is correct, and that reliance is based on nothing more than a programmer's correctness, then we can easily find ourselves in a <a href="http://en.wikipedia.org/wiki/Therac-25">sticky Situation</a>. We can try and mitigate the risks of imparative, hope-based programming with things like unit tests or integration tests, but why mitigate the risk when there's a better way? 
	</p>
	<p>
		Instead of telling a computer <em>how</em> to do it's job, why don't we just tell it <em>what</em> it's job is and let it figure the rest out? 
	</p>
</section>